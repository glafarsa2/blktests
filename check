#!/bin/bash
#
# Copyright (C) 2017 Omar Sandoval
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

. common/rc

_check_dmesg() {
	local dmesg_marker="$1"
	local seqres="${RESULTS_DIR}/${TEST_NAME}"

	if [[ $CHECK_DMESG -eq 0 ]]; then
		return 0
	fi

	dmesg | bash -c "$DMESG_FILTER" | grep -A 9999 "$dmesg_marker" >"${seqres}.dmesg"
	grep -q -e "kernel BUG at" \
	     -e "WARNING:" \
	     -e "BUG:" \
	     -e "Oops:" \
	     -e "possible recursive locking detected" \
	     -e "Internal error" \
	     -e "INFO: suspicious RCU usage" \
	     -e "INFO: possible circular locking dependency detected" \
	     -e "general protection fault:" \
	     "${seqres}.dmesg"
	if [[ $? -eq 0 ]]; then
		return 1
	else
		rm -f "${seqres}.dmesg"
		return 0
	fi
}

# Associative arrays are local by default. declare -g was added in 4.2, but it
# was apparently broken for associative arrays initially.
declare -A LAST_TEST_RUN
declare -A TEST_RUN

_read_last_test_run() {
	local seqres="${RESULTS_DIR}/${TEST_NAME}"

	LAST_TEST_RUN[date]=""
	LAST_TEST_RUN[status]=""
	LAST_TEST_RUN[reason]=""
	LAST_TEST_RUN[exit_status]=""
	LAST_TEST_RUN[runtime]=""

	if [[ ! -e $seqres ]]; then
		return
	fi

	local key value
	while IFS=$'\t' read -r key value; do
		LAST_TEST_RUN["$key"]="$value"
	done <"$seqres"
}

_write_test_run() {
	local key value
	for key in "${!TEST_RUN[@]}"; do
		value="${TEST_RUN["$key"]}"
		printf '%s\t%s\n' "$key" "$value" >>"$seqres"
	done
}

_output_last_test_run() {
	if [[ -v TEST_DEV ]]; then
		echo "$TEST_NAME => $(basename "$TEST_DEV") ..."
	else
		echo "$TEST_NAME ..."
	fi

	local key value
	while IFS= read -r key; do
		if [[ $key =~ ^date|status|reason|exit_status$ ]]; then
			continue
		fi
		value="${LAST_TEST_RUN["$key"]}"
		echo "    ${key} ${value} ..."
	done < <(printf '%s\n' "${!LAST_TEST_RUN[@]}" | sort)
}

_output_status() {
	echo -n "["
	if [[ -t 1 ]]; then
		case "$1" in
		passed)
			tput setaf 2
			;;
		failed)
			tput setaf 1
			;;
		"not run")
			tput setaf 3
			;;
		esac
	fi
	echo -n "$1"
	if [[ -t 1 ]]; then
		tput sgr0
	fi
	echo "]"
}

_output_test_run() {
	if [[ -t 1 ]]; then
		# -4 for date, status, reason, and exit_status, which we don't
		# output, +1 for the test name.
		tput cuu $((${#LAST_TEST_RUN[@]} - 3))
	fi

	if [[ -v TEST_DEV ]]; then
		echo -n "$TEST_NAME => $(basename "$TEST_DEV") ... "
	else
		echo -n "$TEST_NAME ... "
	fi
	_output_status "${TEST_RUN[status]}ed"

	local key last_value value
	while IFS= read -r key; do
		if [[ $key =~ ^date|status|reason|exit_status$ ]]; then
			continue
		fi
		last_value="${LAST_TEST_RUN["$key"]}"
		value="${TEST_RUN["$key"]}"
		echo "    ${key} ${last_value} ... ${value}"
	done < <(printf '%s\n' "${!LAST_TEST_RUN[@]}" | sort)

	while IFS= read -r key; do
		# [[ -v array[key] ]] was added in Bash 4.3. Do it this ugly
		# way to support older versions.
		if [[ -n ${LAST_TEST_RUN["$key"]} || ${LAST_TEST_RUN["$key"]-unset} != unset ]]; then
			continue
		fi
		value="${TEST_RUN["$key"]}"
		echo "    ${key} ... ${value}"
	done < <(printf '%s\n' "${!TEST_RUN[@]}" | sort)
}

_cleanup() {
	if [[ -v TMPDIR ]]; then
		rm -rf "$TMPDIR"
		unset TMPDIR
	fi
}

_call_test() {
	local test_func="$1"
	local seqres="${RESULTS_DIR}/${TEST_NAME}"
	FULL="${seqres}.full"

	_read_last_test_run
	_output_last_test_run

	TEST_RUN[date]="$(date "+%F %T")"

	mkdir -p "$(dirname "$seqres")"
	# Remove leftovers from last time.
	rm -f "${seqres}" "${seqres}."*

	if [[ -w /dev/kmsg ]]; then
		local dmesg_marker="run blktests $TEST_NAME at ${TEST_RUN[date]}"
		echo "$dmesg_marker" >> /dev/kmsg
	else
		local dmesg_marker=""
		CHECK_DMESG=0
	fi

	trap _cleanup EXIT
	TMPDIR="$(mktemp --tmpdir -d "blktests.${category}.${seq}.XXX")"
	if [[ $? -ne 0 ]]; then
		return
	fi

	TIMEFORMAT="%Rs"
	{ time "$test_func" >"${seqres}.out" 2>&1; } 2>"${seqres}.runtime"
	TEST_RUN[exit_status]=$?
	TEST_RUN[runtime]="$(cat "${seqres}.runtime")"
	rm -f "${seqres}.runtime"

	_cleanup

	if ! diff "tests/${TEST_NAME}.out" "${seqres}.out" >/dev/null; then
		mv "${seqres}.out" "${seqres}.out.bad"
		TEST_RUN[status]=fail
		TEST_RUN[reason]=output
	elif [[ ${TEST_RUN[exit_status]} -ne 0 ]]; then
		TEST_RUN[status]=fail
		TEST_RUN[reason]=exit
	elif ! _check_dmesg "$dmesg_marker"; then
		TEST_RUN[status]=fail
		TEST_RUN[reason]=dmesg
	else
		TEST_RUN[status]=pass
	fi
	rm -f "${seqres}.out"

	_write_test_run
	_output_test_run

	if [[ ${TEST_RUN[status]} = pass ]]; then
		return 0
	else
		case "${TEST_RUN[reason]}" in
		output)
			diff -u "tests/${TEST_NAME}.out" "${seqres}.out.bad" | awk "
			{
				if (NR > 10) {
					print \"    ...\"
					print \"    (Run 'diff -u tests/${TEST_NAME}.out ${seqres}.out.bad' to see the entire diff)\"
					exit
				}
				print \"    \" \$0
			}"
			;;
		exit)
			echo "    exited with status ${TEST_RUN[exit_status]}"
			;;
		dmesg)
			echo "    something found in dmesg:"
			awk "
			{
				if (NR > 10) {
					print \"    ...\"
					print \"    (See '${seqres}.dmesg' for the entire message)\"
					exit
				}
				print \"    \" \$0
			}" "${seqres}.dmesg"
			;;
		esac
		return 1
	fi
}

_should_run_test() {
	local test
	local group
	local include_group
	local exclude_group

	if [[ -n ${TESTS[$TEST_NAME]} ]]; then
		return 0
	fi

	local ret=1
	for group in "${TEST_GROUPS[@]}"; do
		if [[ -n ${INCLUDE_GROUPS[$group]} ]]; then
			ret=0
		fi
		if [[ -n ${EXCLUDE_GROUPS[$group]} ]]; then
			return 1
		fi
	done

	return $ret
}

_output_notrun() {
	echo -n "$1 ... "
	_output_status "not run"
	echo "    $SKIP_REASON"
}

_run_test() {
	TEST_NAME="$1"
	CHECK_DMESG=1
	DMESG_FILTER=cat

	if ! . "tests/${TEST_NAME}"; then
		return
	fi

	if [[ ! -v TEST_GROUPS ]]; then
		_warning "${TEST_NAME} does not define TEST_GROUPS"
		return
	fi

	if declare -fF test >/dev/null && declare -fF test_device >/dev/null; then
		_warning "${TEST_NAME} defines both test() and test_device()"
		return
	fi

	if ! declare -fF test >/dev/null && ! declare -fF test_device >/dev/null; then
		_warning "${TEST_NAME} does not define test() or test_device()"
		return
	fi

	if ! _should_run_test; then
		return
	fi

	if declare -fF test >/dev/null; then
		if declare -fF prepare >/dev/null && ! prepare; then
			_output_notrun "$TEST_NAME"
			return
		fi

		RESULTS_DIR="results/nodev"
		_call_test test
	else
		if declare -fF prepare >/dev/null && ! prepare; then
			_output_notrun "$TEST_NAME => *"
			return
		fi

		local ret=0
		for TEST_DEV in "${CATEGORY_TEST_DEVS[@]}"; do
			TEST_DEV_SYSFS="${TEST_DEV_SYSFS_DIRS["$TEST_DEV"]}"
			local test_dev="$(basename "$TEST_DEV")"
			if declare -fF prepare_device >/dev/null && ! prepare_device; then
				_output_notrun "$TEST_NAME => $test_dev"
				continue
			fi
			RESULTS_DIR="results/${test_dev}"
			if ! _call_test test_device; then
				ret=1
			fi
		done
		return $ret
	fi
}

_run_category() {
	local category="$1"

	# Most of this script is written defensively against whitespace in the
	# test name, but we can't handle it in the test logs.
	if [[ $category =~ [[:space:]] ]]; then
		_error "category name \"${category}\" contains whitespace"
		return
	fi

	if ! . "tests/${category}/category"; then
		return
	fi

	if ! declare -fF prepare >/dev/null; then
		_warning "${category} does not define prepare()"
		return
	fi

	if ! declare -fF prepare_device >/dev/null; then
		_warning "${category} does not define prepare_device()"
		return
	fi

	if ! prepare; then
		_output_notrun "$category/***"
		return
	fi

	declare -a CATEGORY_TEST_DEVS
	local test_dev
	for test_dev in "${TEST_DEVS[@]}"; do
		if prepare_device; then
			CATEGORY_TEST_DEVS+=("$test_dev")
		fi
	done
	if [[ ${#CATEGORY_TEST_DEVS} -eq 0 ]]; then
		_output_notrun "$category/***"
		return
	fi

	unset prepare prepare_device

	local ret=0
	local seq
	while IFS= read -r -d '' seq; do
		if ! ( _run_test "${category}/${seq}" ); then
			ret=1
		fi
	done < <(find "tests/${category}" -mindepth 1 -maxdepth 1 -type f \
		 -name '[0-9][0-9][0-9]' -printf '%P\0' | sort -z)
	return $ret
}

_find_sysfs_dir() {
	local test_dev="$1"
	local major=$((0x$(stat -L -c '%t' "$test_dev")))
	local minor=$((0x$(stat -L -c '%T' "$test_dev")))
	local dev="$major:$minor"

	local block_dir part_dir
	for block_dir in /sys/block/*; do
		if [[ $(cat "${block_dir}/dev") = $dev ]]; then
			echo "$block_dir"
			return
		fi
		for part_dir in "$block_dir"/*; do
			if [[ -r ${part_dir}/dev && $(cat "${part_dir}/dev") = $dev ]]; then
				echo "$block_dir"
				return
			fi
		done
	done

	return 1
}

declare -A TEST_DEV_SYSFS_DIRS
_check_test_devs() {
	local test_dev

	for test_dev in "${TEST_DEVS[@]}"; do
		if [[ ! -e $test_dev ]]; then
			_error "${test_dev} does not exist"
		elif [[ ! -b $test_dev ]]; then
			_error "${test_dev} is not a block device"
		fi

		local sysfs_dir="$(_find_sysfs_dir "$test_dev")"
		if [[ $? -ne 0 ]]; then
			_error "could not find sysfs directory for ${test_dev}"
		fi
		TEST_DEV_SYSFS_DIRS["$test_dev"]="$sysfs_dir"
	done
}

_run_tests() {
	local ret=0
	local category
	while IFS= read -r -d '' category; do
		if ! ( _run_category "${category}" ); then
			ret=1
		fi
	done < <(find tests -mindepth 1 -maxdepth 1 -type d -printf '%P\0' | sort -z)
	return $ret
}

usage () {
	USAGE_STRING="\
usage: $0 [-g group] [-x exclude_group] [test...]
       $0 -h

Test groups:
  -g group    run tests belonging to this group; may be specified multiple
              times
  -x group    don't run tests belonging to this group; takes precedence over
              -g, may be specified multiple times

Miscellaneous:
  -h    display this help message and exit

Examples:
Run the default set of tests, i.e., the \"auto\" group:
    ./check
Run all NVMe and SCSI tests except for those that involve discard:
    ./check -g nvme -g scsi -x discard
Run two specific tests:
    ./check block/001 block/002
Run a specific test in addition to the default set of tests:
    ./check -g auto block/003"

	case "$1" in
		out)
			echo "$USAGE_STRING"
			exit 0
			;;
		err)
			echo "$USAGE_STRING" >&2
			exit 1
			;;
	esac
}

declare -A INCLUDE_GROUPS
declare -A EXCLUDE_GROUPS
declare -A TESTS

while getopts "g:x:h" OPT; do
	case "$OPT" in
		g)
			INCLUDE_GROUPS["$OPTARG"]=1
			;;
		x)
			EXCLUDE_GROUPS["$OPTARG"]=1
			;;
		h)
			usage out;
			;;
		*)
			usage err;
			;;
	esac
done

shift $((OPTIND - 1))

for test in "$@"; do
	TESTS["$test"]=1
done

if [[ ${#TESTS[@]} -eq 0 && ${#INCLUDE_GROUPS[@]} -eq 0 ]]; then
	INCLUDE_GROUPS[auto]=1
fi

if ! . config; then
	exit 1
fi

if [[ ! -v TEST_DEVS ]]; then
	_error "\$TEST_DEVS not defined in ./config"
fi

if [[ $EUID -ne 0 ]]; then
	_error "must be run as root"
fi

_check_test_devs
_run_tests
