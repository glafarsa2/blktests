#!/bin/bash
#
# Copyright (C) 2017 Omar Sandoval
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

set -e

. common/rc

prompt_yes_no() {
	if [[ $2 =~ ^[Yy] ]]; then
		local default=0
		local prompt="$1 [Y/n] "
	else
		local default=1
		local prompt="$1 [y/N] "
	fi

	local yn
	read -n 1 -p "${prompt}" yn
	if [[ -n "${yn}" ]]; then
		echo
	fi
	if [[ "${yn}" =~ ^[Yy] ]]; then
		return 0
	elif [[ "${yn}" =~ ^[Nn] ]]; then
		return 1
	else
		return $default
	fi
}

echo "Available test categories:"
while IFS= read -r -d '' category; do
	if [[ $category != meta ]]; then
		echo "    ${category}"
	fi
done < <(find tests -mindepth 1 -maxdepth 1 -type d -printf '%P\0')

read -r -p "Category for new test (pick one of the above or create a new one): " category

if [[ -z $category ]]; then
	exit 1
fi

if [[ $category =~ [[:space:]] ]]; then
	_error "category name must not contain whitespace"
fi

if [[ ! -e tests/${category} ]]; then
	if ! prompt_yes_no "Category does not exist; create it?"; then
		exit 1
	fi
	mkdir -p "tests/${category}"
	cat << EOF > "tests/${category}/category"
#!/bin/bash
#
# TODO: provide a brief description of the category here.
#
# Copyright (C) $(date +%Y) TODO YOUR NAME HERE
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# TODO: source any more common helpers needed for this category script.
# Anything sourced here will also be available in the test scripts.
# Additionally, any functions defined here (except for prepare() and
# prepare_device()) will also be available in the test scripts.
. common/rc

# TODO: prepare() should check whether tests in this category can be run. If
# so, it should return 0. Otherwise, it should return non-zero and set the
# \$SKIP_REASON variable. Usually, prepare() just needs to check that any
# necessary programs and kernel features are available using the _have_foo
# helpers. If prepare() returns non-zero, all tests in this category will be
# skipped.
prepare() {
	_have_root
}

# TODO: prepare_device() should check whether tests in this category can be run
# on the given test device. \$TEST_DEV is the full path of the block device
# (e.g., /dev/nvme0n1 or /dev/sda1), and \$TEST_DEV_SYSFS is the sysfs path of
# the disk (not the partition, e.g., /sys/block/nvme0n1 or /sys/block/sda). If
# tests in this category can be run on the test device, it should return zero.
# Otherwise, it should return non-zero and set the \$SKIP_REASON variable.
# Usually, prepare_device() just needs to check that the test device is the
# right type of hardware or supports any necessary features using the
# _test_dev_foo helpers. Tests in this category will only be run on devices for
# which prepare_device() returns zero.
prepare_device() {
	return 0
}
EOF
	echo "Created tests/${category}/category"
fi

for ((i = 1; ; i++)); do
	seq="$(printf "%03d" $i)"
	test_name="${category}/${seq}"
	if [[ ! -e tests/${test_name} ]]; then
		break
	fi
done

cat << EOF > "tests/${test_name}"
#!/bin/bash
#
# TODO: provide a description of the test here, i.e., what it tests and how. If
# this is a regression test for a patch, reference the patch title:
#
# Regression test for patch "blk-stat: fix blk_stat_sum() if all samples are
# batched".
#
# For a commit, use the first 12 characters of the commit hash and the one-line
# commit summary:
#
# Regression test for commit efd4b81abbe1 ("blk-stat: fix blk_stat_sum() if all
# samples are batched").
#
# Copyright (C) $(date +%Y) TODO YOUR NAME HERE
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# TODO: if this test shouldn't be run by default, remove the "auto" group. If
# this test runs quickly, add it to the "quick" group. If this test honors the
# configured \$TIMEOUT, add it to the "timed" group.
# Add any other groups describing what functionality this tests (e.g.,
# "discard" or "hotplug"). Feel free to create new groups if it makes sense.
TEST_GROUPS=($category auto)
# TODO: fill in a very brief description of what this test does. The
# description should complete the sentence "This test will...". For example,
# "run a mixed read/write workload" would be a good description.
DESCRIPTION=""

# TODO: dmesg is checked after each test run by default. You can suppress this
# by defining:
# CHECK_DMESG=0
# Alternatively, you can filter out any unimportant messages in dmesg like so:
# DMESG_FILTER="grep -v sysfs"

# TODO: if this test has any extra requirements, it should define a prepare()
# function. If the test can be run, prepare() should return 0. Otherwise, it
# should return non-zero and set the \$SKIP_REASON variable. Usually, prepare()
# just needs to check that any necessary programs and kernel features are
# available using the _have_foo helpers. If prepare() returns non-zero, the
# test is skipped.
# prepare() {
# 	_have_foo
# }

# TODO: if this test has extra requirements for what devices it can be run on,
# it should define a prepare_device() function. If the test can be run on
# \$TEST_DEV, then prepare_device() should return zero. Otherwise, it should
# return non-zero and set the \$SKIP_REASON variable. Usually, prepare_device()
# just needs to check that the test device is the right type of hardware or
# supports any necessary features using the _test_dev_foo helpers. The test
# will only be run on devices for which prepare_device() returns zero.
# prepare_device() {
# 	_test_dev_foo
# }

# TODO: define the test. The output of this function (stdout and stderr) will
# be compared to tests/\${TEST_NAME}.out. If it does not match, the test is
# considered a failure. If the test runs a command which has unnecessary
# output, either redirect that output to \$FULL or /dev/null, or filter out the
# unimportant parts (e.g., with grep or the _filter_foo helpers).
#
# Additionally, if the test function returns non-zero, it is considered a
# failure. You should prefer letting the test fail because of broken output
# over, say, checking the exit status of every command you run.
#
# Various variables are defined for the test:
#    - \$TEST_NAME -- the full name of the test.
#    - \$TMPDIR -- a temporary directory deleted after the test is run.
#    - \$FULL -- a file where the test may log verbose output (e.g., the output
#               of fio or mkfs).
#    - \$TEST_RUN -- an associative array of additional test data to display
#                   after the test is run and store for comparison on future
#                   test runs. Use like TEST_RUN[iops]="\$(measure_iops)".
#
# Many tests do not need a test device (usually because they set up their own
# virtual devices, like null-blk or loop). These tests should define the test()
# function.
#
# Tests that require a test device should rename test() to test_device(). These
# tests will be run with a few more variables defined:
#    - \$TEST_DEV -- the block device to run the test on (e.g., /dev/sda1).
#    - \$TEST_DEV_SYSFS -- the sysfs directory of the device (e.g., /sys/block/sda).
test() {
	echo "Running \${TEST_NAME}"

	# TODO: fill in the test case.

	echo "Test complete"
}

# Finally, some coding style guidlines:
# - Indent with tabs.
# - Don't add a space before the parentheses or a newline before the curly brace
#   in function definitions.
# - Variables set and used by the testing framework are in caps with underscores.
#   E.g., TEST_NAME and GROUPS. Variables local to the test are lowercase
#   with underscores.
# - Functions defined by the testing framework, including helpers, have a leading
#   underscore. E.g., _have_scsi_debug. Functions local to the test or category
#   should not have a leading underscore.
# - Use the bash [[ ]] form of tests instead of [ ].
# - Always quote variable expansions unless the variable is a number or inside of
#   a [[ ]] test.
# - Use the \$() form of command substitution instead of backticks.
# - Use bash for loops instead of seq. E.g., for ((i = 0; i < 10; i++)), not
#   for i in \$(seq 0 9).
EOF
chmod +x "tests/${test_name}"
echo "Created tests/${test_name}"

cat << EOF > "tests/${test_name}.out"
Running ${test_name}
Test complete
EOF
echo "Created tests/${test_name}.out"
